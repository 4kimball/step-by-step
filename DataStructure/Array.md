# Array

> 자료구조는 크게 메모리 공간 기반의 연속방식과 포인터 기반의 연결방식으로 나뉜다. 여기서 Array는 연속 방식의 가장 기본이 되는 자료구조다.



배열은 같은 자료형의 데이터가 메모리에 연속적으로 저장된 형태다. 배열은 `index`로 해당 원소에 접근할 수 있고, 모든 원소를 `Big-O(1)`에 접근이 가능하다. 따라서 **Random Access**를 할 수 있는 장점이 있다.



### 원소를 Big-O(1)에 조회할 수 있는 이유는?

32bit 이상의 시스템에서 C언어를 기준으로 봤을 때 다음과 같이 배열을 선언했다고 하자.

```c
int arr[5] = {6, 1, 9, 7, 4};
```

C언어에서 int형은 4byte의 공간을 차지한다. 변수들은 고유의 주소를 갖고있으며 배열은 첫 원소의 주소를 갖게된다. 여기서 배열은 메모리 공간에서 연속적으로 존재하기 때문에 첫 원소의 주소만 알면 나머지 원소들의 주소도 쉽게 알 수 있을 것이다.

배열에서 6의 주소를 0x00이라고 하면 1의 주소는 0x04가 된다. 이렇게 `index`를 통해 배열에 접근을 하면 주소를 계산하여 `Big-O(1)`에 접근이 가능한 것이다.

예를 들어, 4번 째 원소에 접근을 한다고 하면 (4-1)x4 = 12이고 이를 16진수로 변환하면 0x0C가 된다. 



### 배열에서 삽입과 삭제

배열에서 삽입과 삭제를 실행해보자. 

배열은 메모리 공간에서 연속적으로 존재할 때 중간위치에 어떠한 원소를 삽입한다고 하면 삽입하는 위치를 기준으로 뒤의 원소를 뒤로 밀어야할 것이다. 이때 `shift`를 해줘야하기 때문에 `Big-O(n)`의 시간 복잡도가 발생한다.

배열에서 삭제도 마찬가지이며 중간의 원소를 삭제한다고 했을 때 삭제되는 원소의 위치를 기준으로 뒤에 있는 원소를 차례대로 앞으로 `shift`해야하기 때문에 역시 `Big-O(n)`의 시간 복잡도를 갖는다.

---



만약 10개의 메모리 공간을 확보하는 배열을 선언했을 때 2개의 공간만 채우면 나머지 8개의 공간에서 낭비가 발생한다. 또한 12개의 원소를 저장한다면 배열의 크기를 늘려야한다. 이러한 문제를 해결하기 위해 배열의 크기를 자동으로 `resizing`하는 **동적 배열**이 등장하게 된다.

### 동적 배열

C++에서는 `vector`, JAVA는 `ArrayList`라는 동적 배열 자료형이 존재한다.

동적 배열은 생성될 때 초깃값을 작게 잡고 데이터가 추가되면서 꽉 채워졌을 때 크기가 늘어난 배열에 복사한다. 대부분 2배씩 늘리는 `더블링`으로 크기를 늘려나간다. 

하지만 모든 언어가 `더블링`의 형태로 크기를 늘려가지 않고 크기의 재할당 비율인 `Growth Factor`에 따라 크기를 늘려간다. 

동적 배열도 원소에 접근할 때 `Big-O(1)`의 시간 복잡도를 갖지만 정해진 크기에 원소가 모두 찼을 때는 기존 데이터를 복사하는 작업이 필요하며 `Big-O(n)`의 비용이 발생한다. 따라서 삽입이 빈번하게 발생하는 상황에서 불리하다.

