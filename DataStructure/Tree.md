# Tree

> Array, Stack, Queue와 같은 선형 자료구조로 표현하기 힘든 것들이 있다. 예를 들면 회사의 조직도, 대진표 등과 같은 계층적인 구조를 나타내는 것들이다. 이들을 표현하기 위해서는 계층적인 구조를 갖는 Tree를 활용할 수 있다.



### 트리의 구조

트리는 `노드`와 `간선`으로 연결되어 있으며 노드 간에는 상/하위 관계가 존재한다.

- **Root Node** : 트리 구조에서 모든 노드들 중 최상단에 위치한 노드이다.
- **Leaf Node** : 트리 구조에서 모든 노드들 중 최하단에 위치한 노드이다.
- **Parent Node** : 특정 노드에서 바로 위에 있는 노드를 부모 노드라고 한다. 루트 노드를 제외하고 모든 노드는 부모 노드를 갖는다.
- **Child Node** : 특정 노드에서 바로 아래에 있는 노드를 자식 노드라고 한다. 리프 노드를 제외한 모든 노드는 자식 노드를 갖는다.
- **Sibling Node** : 같은 부모 노드를 공유하고 있는 노드들을 형제 노드라고 한다.
- **Degree** : 한 노드에 연결된 서브 트리의 개수를 차수라고 한다.
- **Level** : 루트 노드부터 특정 노드까지 방문한 총 노드의 수를 레벨이라고 한다.
- **Depth** : 높이 또는 깊이라고 하며 트리의 최대 레벨 수를 뜻한다.



### 트리의 재귀적 속성

> 종만북을 바탕으로 정리

트리 내에 특정 노드를 기준으로 서브 트리들이 존재하고 그 서브 트리도 또 하나의 서브 트리가 존재한다. 이는 트리가 재귀적인 성질을 갖는다는 것을 알 수 있다.

따라서 트리를 탐색할 때 재귀호출을 이용하게 된다. 재귀호출을 언제하느냐에 따라 `전위 순회`, `중위 순회`, `후위 순회`가 된다.



### 트리의 순회

> 트리를 순회할 때는 **노드는 오직 한 번만 방문한다**는 기본 규칙을 지켜야 한다. 트리는 1차원적인 구조가 아니기 때문에 한 가지의 순서가 존재하지 않고 상황에 따라 다른 순서를 정의해야 한다.



트리 내의 노드를 다음과 같이 정의하였고 이를 활용하여 트리의 순회를 정리한다.

```python
class Node():

    def __init__(self, data, left=-1, right=-1):
        self.data = data
        self.left = left
        self.right = right
```



#### 전위 순회

전위 순회는 루트 노드에서 계속 왼쪽으로 이동하면서 리프 노드가 나올 때까지 순서대로 방문한다. 즉, 방문하는 순서는 `부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식노드`순으로 방문을 한다. 부모 노드를 언제 방문하냐느에 따라 순회의 이름을 정의한다.

이를 코드로 작성하면 다음과 같다.

1번 노드를 루트노드로 순회를 시작한다. 순회를 하며 어떤 노드를 방문했는지 출력을 하는데 부모 노드를 출력하고 부모 노드의 왼쪽 자식노드, 오른쪽 자식노드를 순서로 재귀호출을 한다.

```python
def pre_order(node):
    print("node") # 현재 방문한 노드를 출력한다.
    if tree[node].left != -1:
        pre_order(tree[node].left)
    if tree[node].right != -1:
        pre_order(tree[node].right)

pre_order(1)
```



#### 중위 순회

중위 순회는 맨 왼쪽에 있는 리프 노드로 이동한 뒤에 순회를 시작한다. 이때부터 방문의 순서는 `왼쪽 자식노드 -> 부모 노드 -> 오른쪽 자식노드`가 되며 부모 노드를 중간에 방문을 하게된다.

이를 코드로 작성하면 다음과 같다.

1번 루트 노드를 시작으로 순회를 시작할 때 루트 노드를 출력하는 것이아니라 계속해서 왼쪽 자식노드를 방문한다. 왼쪽의 리프노드를 방문했을 때 해당 노드를 출력하고 재귀호출을 한 시점(부모 노드)으로 돌아간다.

```python
def in_order(node):
    if tree[node].left != -1:
        in_order(tree[node].left)
    print("node") # 현재 방문한 노드를 출력한다.
    if tree[node].right != -1:
        in_order(tree[node].right)

pre_order(1)
```



#### 후위 순회

후위 순회는 맨 왼쪽에 있는 리프 노드로 이동하여 방문하고 해당 부모 노드의 오른쪽 리프 노드로 이동한다.  방문의 순서는 `왼쪽 자식노드 -> 오른쪽 자식노드 -> 부모 노드`이며 부모 노드를 마지막에 방문한다.

이를 코드로 작성하면 다음과 같다.

왼쪽 리프노드를 방문한 뒤에 재귀호출을 한 시점으로 돌아가면 해당 부모 노드의 오른쪽 자식노드를 먼저 방문하게 된다. 왼쪽, 오른쪽 자식노드를 모두 방문했을 때 다시 돌아와 부모 노드를 방문한다.

```python
def post_order(node):
    if tree[node].left != -1:
        post_order(tree[node].left)
    if tree[node].right != -1:
        post_order(tree[node].right)
    print("node") # 현재 방문한 노드를 출력한다.

pre_order(1)
```



---



### 이진 탐색 트리(Binary Search Tree)

이진 트리는 노드들이 자식 노드를 최대 2개 갖는 트리이다. 이때 이진 트리에 저장된 데이터를 효율적으로 탐색하기 위해 특정 규칙대로 데이터를 저장한 검색 트리를 `이진 탐색 트리`라고 한다.

이진 탐색 트리에 저장된 데이터들은 다음과 같은 특징을 갖는다.

- 현재 노드보다 작은 데이터는 왼쪽 서브트리에 저장하고 큰 데이터는 오른쪽 서브트리에 저장한다.
- 루트 노드를 0 또는 1이라는 인덱스를 시작으로 위의 왼쪽부터 순서대로 인덱스를 갖는다.
- 인덱스를 통해 특정 데이터를 탐색할 수 있고 `O(log n)`의 시간 복잡도를 갖는다.

1에서 6까지의 수를 이진 탐색 트리에 저장해보자.

`tree`라는 리스트는 1차원 리스트이고 각각의 인덱스에 1에서 6까지의 수가 저장되어 있다. 루트 노드의 인덱스인 1에는 4가 저장되어있다.

```python
def binary_search_tree(idx):
    global number # 노드에 저장할 수
    if idx > 6:
        return 
    binary_search_tree(idx*2) # 해당 인덱스에서 x2를 하여 왼쪽 자식노드로 이동
    tree[idx] = number
    number += 1 # 해당 인덱스에 수를 저장하고 다음 저장을 위해 수를 증가시킨다.
    binary_search_tree(idx*2+1) # 오른쪽 자식노드로 이동
```

