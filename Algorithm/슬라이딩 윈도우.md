# 슬라이딩 윈도우

> 특정 길이의 창문을 옆으로 밀면서 탐색한다.



### :bulb: 배경

`3, 5, 3, 1, 7, 2, 9, 4`의 수열에서 연속되는 숫자 3개를 선택해서 합을 구할 때 최대합을 구하라.

위와 같은 문제가 있다고 하자. 이는 아래의 코드와 같이 2중 for문을 통해 해결할 수 있을 것이다.

```python
numbers = [3, 5, 3, 1, 7, 2, 9, 4]
N = len(numbers)
K = 3
max_sum = 0
for i in range(N-K+1):
    total = 0
    for j in range(K):
        total += numbers[i+j]

    if max_sum < total:
        max_sum = total

print(max_sum)
```

하지만 불필요한 접근으로 인해 수열의 길이인 N이 길어질수록 비효율적이다. 어디서 불필요한 접근이 발생할까? 처음 `3, 5, 3`에 대한 계산이 진행된 후에 다시 `5, 3, 1`에 대해 계산이 진행된다. 여기서 `5, 3`은 그대로이고 한 개의 숫자만 변경되었다. 한 개의 숫자만 변경되었지만 두 번째 for문에서 인덱스 j는 다시 `5, 3`에 접근하고 있다.

이처럼 2중 for문을 사용할 경우 한 번만 접근해도 되는 것을 두 번 접근하여 시간 복잡도가 높아지고 있다. 이를 해결하기위해 **슬라이딩 윈도우를 사용할 수 있다.**



### :bulb: 개념

`3, 5, 3, 1, 7, 2, 9, 4`에서 처음에 `3, 5, 3`에 접근을 한다. 두 번째는 `5, 3, 1`에 접근할 때 `5, 3`은 그대로둔다. 대신 `3`을 빼고 `1`만 추가하면 될 것이다.

**3** **5** **3** -> 3 **5** **3** **1** -> 3 5 **3** **1** **7** 처럼 한 칸 이동할 때마다 처음 것은 빼주고 그 다음 숫자를 추가해주도록 한다. 이를 구현하기위해 자료구조 deque를 활용한다.

- 먼저 deque에 K개의 수를 추가한다.
- K개의 수가 deque에 저장되어있다면 최대합을 구하기위해 deque의 값을 모두 더한 후 비교한다.
- 비교 이후에는 deque에서 가장 먼저 저장된 수를 제거한다.

```python
numbers = [3, 5, 3, 1, 7, 2, 9, 4]
N = len(numbers)
K = 3
max_sum = 0
dq = deque()
for k, v in enumerate(numbers):
    dq.append(v)
    # 3개의 숫자를 더하기 전까지는 계속 숫자를 더한다.
    if k < K - 1:
        continue

    if max_sum < sum(dq):
        max_sum = sum(dq)
    dq.popleft()

print(max_sum)
```



슬라이딩 윈도우를 사용하면 한 개의 for문을 사용하여 해결할 수 있다. 슬라이딩 윈도우의 개념을 통해 다양한 문제에 접근하면서 응용력을 키워야겠다.

