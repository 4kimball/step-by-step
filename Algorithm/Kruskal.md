# Kruskal

> 최소 신장 트리를 구하는 알고리즘



### 최소 신장 트리란?

N개의 노드로 이루어진 그래프가 있다. 이 그래프에는 다양한 부분 그래프가 존재할 수 있다. 

여기서 부분 그래프를 **신장 트리**라하며 N개의 노드를 N-1개의 간선으로 연결하고, 순환되지 않는 구조를 가져야만 신장 트리라 할 수 있다.

또한, 신장 트리 중에서 비용이 가장 적은 것을 **최소 신장 트리**라고 한다. 그리고 최소 신장 트리를 구하는 알고리즘은 `크루스칼 알고리즘`과 `프림 알고리즘`이 존재한다.



### 배경

- N개의 섬을 연결하는 다리가 있다고 하자. 특정 섬에서 다른 섬까지 다리를 건너면 무조건 건너갈 수 있지만 통행료를 지불해야하고, 다리에 따라 통행료가 차이가 날 수 있다. 이때, N개의 섬을 한 번씩만 방문하도록 다리를 건너려고 하는데 최소 비용이 되도록 구해보자.

- N개의 섬을 한 번씩 방문하는 경로를 여러가지 경우의 수가 나타날 수 있다. 하지만 다리를 건널 때 통행료가 최소가 되도록 방문하는 조건이 있기 때문에 조건에 맞는 하나의 경우의 수를 구할 수 있어야한다.
- 이때 사용할 수 있는 알고리즘이 **크루스칼 알고리즘**이다.



### :bulb: 개념

- 다리의 정보를 모두 입력받아 통행료를 기준으로 오름차순으로 정렬한다. 즉 A에서 B로 갈 때 C만큼의 비용이 든다는 정보를 갖고 C 기준으로 오름차순 정렬을 하는 것이다.
- 이제 가장 적은 비용부터 확인을 해서 A->B의 다리를 건너도되는지 확인을 해야한다.
- 여기서 중요한 것은 N개의 모든 섬을 한 번씩만 방문하기위해서는 **N-1개의 다리만 건너면 되고**, **순환하지 않는 구조**를 만들어야한다는 것이다.
  - 여기서 **서로소 집합**이라는 개념을 활용한다.
  - 각각의 노드는 대표 노드를 가리키는 집합을 갖고있다. 초기에는 자기 자신을 가리키게되고 연결 상태에 따라 다른 노드가 대표노드가 될 수 있다. 
  - 즉, **A에서 B로 건너는 다리에서 A와 B의 대표노드가 다르면** 건널 수 있는 것이다. **다르다면 순환하지 않는 구조가 되기** 때문이다.
- 서로소 집합을 활용하기 위한 과정을 알아보자.

```python
# 자기 자신을 가리키도록 초기화 : make_set
N = 5
p = [n for n in range(N)]
```

```python
# a 노드의 대표노드를 찾아주기
def find_set(a):
    # 자기 자신을 가리키면 a를 그대로 반환
    if p[a] == a:
        return a
    else:
        # 다른 노드가 대표노드라면 a가 속한 최상위 노드 찾기
        b = find_set(p[a])
        p[a] = b
        return b
```

```python
# b노드의 대표 노드를 a로 설정하기
def union(a, b):
    a = find_set(a)
    b = find_set(b)
    if a != b:
        p[b] = a
```

- 이제 위에서 설정한 집합을 통해 크루스칼 알고리즘을 쉽게 구할 수 있다.

```python
# a->b로 갈 때 c 비용
for a, b, c in graph:
    # 대표 노드가 다르다면 a에서 b로 건널 수 있다.
    if find_set(a) != find_set(b):
        # 이제 a에서 b로 건넜기 때문에 b의 대표노드를 a로 설정한다.
        union(a, b)
        # 지금까지 건너온 다리를 증가시키고
        bridge += 1
        # 비용을 C만큼 증가시킨다.
        total += c
     # N-1만큼의 다리를 건너왔다면 모든 섬을 방문한 것이기 때문에 종료한다.   
     if bridge == N-1:
        break
        
# 최종적으로 모든 섬을 한 번씩 방문할 때 최소 통행료는 total이 된다.
```

