# Binary Search



### 이진 검색

탐색을 하는 방법에는 여러가지가 있다. 그 중 이분탐색은 탐색의 범위를 좁혀가면서 원하는 타겟을 구한다.

기본 동작은 다음과 같다. 1부터 100까지의 수 중에서 77을 찾아보자.

1과 100의 중간인 50을 선택하고 원하는 타겟인 77이 아니기 때문에 새로운 범위를 찾아야한다. 이때 50은 77보다 작기 때문에 1과 100 중 작은 수인 1을 51로 갱신한다. 

그 다음, 51과 100의 중간인 75를 선택, 77보다 작기 때문에 다시 76과 100사이의 중간인 87 선택을 한다. 이런식으로 진행을 하면 7번의 비교를 통해 77을 찾을 수 있다.

핵심은 탐색해야하는 범위를 left와 right로 정하고 left가 right와 같아지거나 커지면 탐색이 종료되고, left와 right를 통해 중간값인 mid를 구하여 타겟을 찾는 것이다.



`이진 검색의 문제점`

- x축에 0부터 100까지의 수가 존재하고 left=0, right=100으로 초기화를 해보자. 
- left와 right를 통해 mid값을 구하게 되는데 이 식은 다음과 같다.
  - mid = (left + right ) / 2
- 이 과정에서 문제점이 발생한다. left + right를 하는 과정에서 `오버플로우`가 발생할 수 있다는 것이다.
- left + right가 자료형의 최댓값을 넘어서 `오버플로우`가 발생할 수 있기 때문에 해당 코드는 다음과 같이 수정해야 한다.
  - mid = left + (right - left) / 2
- 위의 문제는 자료형을 사용하는 C, C++, JAVA 등의 언어에서 주의해야하고 파이썬의 경우 `임의 정밀도 정수형`을 지원하기 때문에 신경쓰지 않아도 된다.

---

### 1. 이진검색

> 정렬된 숫자들이 포함된 리스트를 입력받아 target에 해당하는 인덱스를 찾아보자.

- 이진검색을 하기위해서 리스트의 수들이 정렬이 되어있어야 한다. 왜냐하면 mid값과 target값을 통해 범위를 갱신해야하는데 정렬이 되어있지 않다면 비교횟수가 증가할 것이고 이진검색을 하는 이유가 사라진다.
- left는 가장 작은 값을 갖는 인덱스인 0으로, right는 가장 큰 값을 갖는 인덱스인 `len(numbers)-1`을 갖도록 한다.
- 현재 left와 right는 각각 가장 작은 값과 큰 값을 가리키고 있다.
- 이제 이를 활용하여 중간값을 구한다. 
- mid가 가리키는 값이 target보다 작다면 left를 증가시켜야하고 크다면 right를 감소시켜야한다.
- 그리고 mid가 가리키는 값이 target이라면 종료한다.

```python
numbers = [-1, 0, 3, 5, 9, 12]
target = 9

left = 0
right = len(numbers) - 1

while left <= right:
    mid = (left+right)//2

    if numbers[mid] < target:
        left = mid + 1
    elif numbers[mid] > target:
        right = mid - 1
    else:
        answer = mid
        break
print(answer)
```

---



